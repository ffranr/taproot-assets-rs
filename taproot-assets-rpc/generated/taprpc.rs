// This file is @generated by prost-build.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetMeta {
    ///
    /// The raw data of the asset meta data. Based on the type below, this may be
    /// structured data such as a text file or PDF. The size of the data is limited
    /// to 1MiB.
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    /// The type of the asset meta data.
    #[prost(enumeration = "AssetMetaType", tag = "2")]
    pub r#type: i32,
    ///
    /// The hash of the meta. This is the hash of the TLV serialization of the meta
    /// itself.
    #[prost(bytes = "vec", tag = "3")]
    pub meta_hash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetRequest {
    #[prost(bool, tag = "1")]
    pub with_witness: bool,
    #[prost(bool, tag = "2")]
    pub include_spent: bool,
    #[prost(bool, tag = "3")]
    pub include_leased: bool,
    /// List assets that aren't confirmed yet. Only freshly minted assets will
    /// show in the asset list with a block height of 0. All other forms of
    /// unconfirmed assets will not appear in the list until the transaction is
    /// confirmed (check either transfers or receives for unconfirmed outbound or
    /// inbound assets).
    #[prost(bool, tag = "4")]
    pub include_unconfirmed_mints: bool,
    /// Only return assets with amount greater or equal to this value.
    #[prost(uint64, tag = "5")]
    pub min_amount: u64,
    /// Only return assets with amount less or equal to this value.
    #[prost(uint64, tag = "6")]
    pub max_amount: u64,
    /// Only return assets that belong to the group with this key.
    #[prost(bytes = "vec", tag = "7")]
    pub group_key: ::prost::alloc::vec::Vec<u8>,
    /// Return all assets that use this script key.
    #[prost(message, optional, tag = "8")]
    pub script_key: ::core::option::Option<ScriptKey>,
    /// Return all assets that are currently anchored on this outpoint.
    #[prost(message, optional, tag = "9")]
    pub anchor_outpoint: ::core::option::Option<OutPoint>,
    /// The script key type to filter the assets by. If not set, only assets with
    /// a BIP-0086 script key will be returned (which is the equivalent of
    /// setting script_key_type.explicit_type = SCRIPT_KEY_BIP86). If the type
    /// is set to SCRIPT_KEY_BURN or SCRIPT_KEY_TOMBSTONE the include_spent flag
    /// will automatically be set to true, because assets of that type are always
    /// marked as spent.
    #[prost(message, optional, tag = "10")]
    pub script_key_type: ::core::option::Option<ScriptKeyTypeQuery>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnchorInfo {
    /// The transaction that anchors the Taproot Asset commitment where the asset
    ///   resides.
    #[prost(bytes = "vec", tag = "1")]
    pub anchor_tx: ::prost::alloc::vec::Vec<u8>,
    /// The block hash the contains the anchor transaction above.
    #[prost(string, tag = "3")]
    pub anchor_block_hash: ::prost::alloc::string::String,
    /// The outpoint (txid:vout) that stores the Taproot Asset commitment.
    #[prost(string, tag = "4")]
    pub anchor_outpoint: ::prost::alloc::string::String,
    ///
    /// The raw internal key that was used to create the anchor Taproot output key.
    #[prost(bytes = "vec", tag = "5")]
    pub internal_key: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The Taproot merkle root hash of the anchor output the asset was committed
    /// to. If there is no Tapscript sibling, this is equal to the Taproot Asset
    /// root commitment hash.
    #[prost(bytes = "vec", tag = "6")]
    pub merkle_root: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The serialized preimage of a Tapscript sibling, if there was one. If this
    /// is empty, then the merkle_root hash is equal to the Taproot root hash of the
    /// anchor output.
    #[prost(bytes = "vec", tag = "7")]
    pub tapscript_sibling: ::prost::alloc::vec::Vec<u8>,
    /// The height of the block which contains the anchor transaction.
    #[prost(uint32, tag = "8")]
    pub block_height: u32,
    /// The UTC Unix timestamp of the block containing the anchor transaction.
    #[prost(int64, tag = "9")]
    pub block_timestamp: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisInfo {
    /// The first outpoint of the transaction that created the asset (txid:vout).
    #[prost(string, tag = "1")]
    pub genesis_point: ::prost::alloc::string::String,
    /// The name of the asset.
    #[prost(string, tag = "2")]
    pub name: ::prost::alloc::string::String,
    /// The hash of the meta data for this genesis asset.
    #[prost(bytes = "vec", tag = "3")]
    pub meta_hash: ::prost::alloc::vec::Vec<u8>,
    /// The asset ID that uniquely identifies the asset.
    #[prost(bytes = "vec", tag = "4")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    /// The type of the asset.
    #[prost(enumeration = "AssetType", tag = "5")]
    pub asset_type: i32,
    ///
    /// The index of the output that carries the unique Taproot Asset commitment in
    /// the genesis transaction.
    #[prost(uint32, tag = "6")]
    pub output_index: u32,
}
///
/// This message represents an external key used for deriving and managing
/// hierarchical deterministic (HD) wallet addresses according to BIP-86.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExternalKey {
    ///
    /// This field specifies the extended public key derived at depth 3 of the
    /// BIP-86 hierarchy (e.g., m/86'/0'/0'). This key serves as the parent key for
    /// deriving child public keys and addresses.
    #[prost(string, tag = "1")]
    pub xpub: ::prost::alloc::string::String,
    ///
    /// This field specifies the fingerprint of the master key, derived from the
    /// first 4 bytes of the hash160 of the master public key. It is used to
    /// identify the master key in BIP-86 derivation schemes.
    #[prost(bytes = "vec", tag = "2")]
    pub master_fingerprint: ::prost::alloc::vec::Vec<u8>,
    ///
    /// This field specifies the extended BIP-86 derivation path used to derive a
    /// child key from the XPub. Starting from the base path of the XPub
    /// (e.g., m/86'/0'/0'), this path must contain exactly 5 components in total
    /// (e.g., m/86'/0'/0'/0/0), with the additional components defining specific
    /// child keys, such as individual addresses.
    #[prost(string, tag = "3")]
    pub derivation_path: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupKeyRequest {
    ///
    /// The internal key for the asset group before any tweaks have been applied.
    /// If this field is set then external_key must be empty, and vice versa.
    #[prost(message, optional, tag = "1")]
    pub raw_key: ::core::option::Option<KeyDescriptor>,
    ///
    /// The genesis of the group anchor asset, which is used to derive the single
    /// tweak for the group key. For a new group key, this will be the genesis of
    /// new_asset.
    #[prost(message, optional, tag = "2")]
    pub anchor_genesis: ::core::option::Option<GenesisInfo>,
    ///
    /// The optional root of a tapscript tree that will be used when constructing a
    /// new asset group key. This enables future issuance authorized with a script
    /// witness.
    #[prost(bytes = "vec", tag = "3")]
    pub tapscript_root: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The serialized asset which we are requesting group membership for. A
    /// successful request will produce a witness that authorizes this asset to be a
    /// member of this asset group.
    #[prost(bytes = "vec", tag = "4")]
    pub new_asset: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The external key is an optional field that allows specifying an
    /// external signing key for the group virtual transaction during minting.
    /// This key enables signing operations to be performed externally, outside
    /// the daemon.
    ///
    /// If this field is set then raw_key must be empty, and vice versa.
    #[prost(message, optional, tag = "5")]
    pub external_key: ::core::option::Option<ExternalKey>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TxOut {
    /// The value of the output being spent.
    #[prost(int64, tag = "1")]
    pub value: i64,
    /// The script of the output being spent.
    #[prost(bytes = "vec", tag = "2")]
    pub pk_script: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupVirtualTx {
    ///
    /// The virtual transaction that represents the genesis state transition of a
    /// grouped asset.
    #[prost(bytes = "vec", tag = "1")]
    pub transaction: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The transaction output that represents a grouped asset. The tweaked
    /// group key is set as the PkScript of this output. This is used in combination
    /// with Tx to produce an asset group witness.
    #[prost(message, optional, tag = "2")]
    pub prev_out: ::core::option::Option<TxOut>,
    ///
    /// The asset ID of the grouped asset in a GroupKeyRequest. This ID is
    /// needed to construct a sign descriptor, as it is the single tweak for the
    /// group internal key.
    #[prost(bytes = "vec", tag = "3")]
    pub genesis_id: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The tweaked group key for a specific GroupKeyRequest. This is used to
    /// construct a complete group key after producing an asset group witness.
    #[prost(bytes = "vec", tag = "4")]
    pub tweaked_key: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupWitness {
    /// The asset ID of the pending asset that should be assigned this asset
    /// group witness.
    #[prost(bytes = "vec", tag = "1")]
    pub genesis_id: ::prost::alloc::vec::Vec<u8>,
    /// The serialized witness stack for the asset group.
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub witness: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetGroup {
    /// The raw group key which is a normal public key.
    #[prost(bytes = "vec", tag = "1")]
    pub raw_group_key: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The tweaked group key, which is derived based on the genesis point and also
    /// asset type.
    #[prost(bytes = "vec", tag = "2")]
    pub tweaked_group_key: ::prost::alloc::vec::Vec<u8>,
    ///
    /// A witness that authorizes a specific asset to be part of the asset group
    /// specified by the above key.
    #[prost(bytes = "vec", tag = "3")]
    pub asset_witness: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The root hash of a tapscript tree, which enables future issuance authorized
    /// with a script witness.
    #[prost(bytes = "vec", tag = "4")]
    pub tapscript_root: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupKeyReveal {
    /// The raw group key which is a normal public key.
    #[prost(bytes = "vec", tag = "1")]
    pub raw_group_key: ::prost::alloc::vec::Vec<u8>,
    /// The tapscript root included in the tweaked group key, which may be empty.
    #[prost(bytes = "vec", tag = "2")]
    pub tapscript_root: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GenesisReveal {
    /// The base genesis information in the genesis reveal.
    #[prost(message, optional, tag = "1")]
    pub genesis_base_reveal: ::core::option::Option<GenesisInfo>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct DecimalDisplay {
    ///
    /// Decimal display dictates the number of decimal places to shift the amount to
    /// the left converting from Taproot Asset integer representation to a
    /// UX-recognizable fractional quantity.
    ///
    /// For example, if the decimal_display value is 2 and there's 100 of those
    /// assets, then a wallet would display the amount as "1.00". This field is
    /// intended as information for wallets that display balances and has no impact
    /// on the behavior of the daemon or any other part of the protocol. This value
    /// is encoded in the MetaData field as a JSON field, therefore it is only
    /// compatible with assets that have a JSON MetaData field.
    #[prost(uint32, tag = "1")]
    pub decimal_display: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Asset {
    /// The version of the Taproot Asset.
    #[prost(enumeration = "AssetVersion", tag = "1")]
    pub version: i32,
    /// The base genesis information of an asset. This information never changes.
    #[prost(message, optional, tag = "2")]
    pub asset_genesis: ::core::option::Option<GenesisInfo>,
    /// The total amount of the asset stored in this Taproot Asset UTXO.
    #[prost(uint64, tag = "4")]
    pub amount: u64,
    /// An optional locktime, as with Bitcoin transactions.
    #[prost(int32, tag = "5")]
    pub lock_time: i32,
    /// An optional relative lock time, same as Bitcoin transactions.
    #[prost(int32, tag = "6")]
    pub relative_lock_time: i32,
    /// The version of the script, only version 0 is defined at present.
    #[prost(int32, tag = "7")]
    pub script_version: i32,
    /// The script key of the asset, which can be spent under Taproot semantics.
    #[prost(bytes = "vec", tag = "9")]
    pub script_key: ::prost::alloc::vec::Vec<u8>,
    /// Indicates whether the script key is known to the wallet of the lnd node
    /// connected to the Taproot Asset daemon.
    #[prost(bool, tag = "10")]
    pub script_key_is_local: bool,
    /// The information related to the key group of an asset (if it exists).
    #[prost(message, optional, tag = "11")]
    pub asset_group: ::core::option::Option<AssetGroup>,
    /// Describes where in the chain the asset is currently anchored.
    #[prost(message, optional, tag = "12")]
    pub chain_anchor: ::core::option::Option<AnchorInfo>,
    #[prost(message, repeated, tag = "13")]
    pub prev_witnesses: ::prost::alloc::vec::Vec<PrevWitness>,
    /// Indicates whether the asset has been spent.
    #[prost(bool, tag = "14")]
    pub is_spent: bool,
    /// If the asset has been leased, this is the owner (application ID) of the
    /// lease.
    #[prost(bytes = "vec", tag = "15")]
    pub lease_owner: ::prost::alloc::vec::Vec<u8>,
    /// If the asset has been leased, this is the expiry of the lease as a Unix
    /// timestamp in seconds.
    #[prost(int64, tag = "16")]
    pub lease_expiry: i64,
    /// Indicates whether this transfer was an asset burn. If true, the number of
    /// assets in this output are destroyed and can no longer be spent.
    #[prost(bool, tag = "17")]
    pub is_burn: bool,
    /// Deprecated, use script_key_type instead!
    /// Indicates whether this script key has either been derived by the local
    /// wallet or was explicitly declared to be known by using the
    /// DeclareScriptKey RPC. Knowing the key conceptually means the key belongs
    /// to the local wallet or is at least known by a software that operates on
    /// the local wallet. The flag is never serialized in proofs, so this is
    /// never explicitly set for keys foreign to the local wallet. Therefore, if
    /// this method returns true for a script key, it means the asset with the
    /// script key will be shown in the wallet balance.
    #[prost(bool, tag = "18")]
    pub script_key_declared_known: bool,
    /// Deprecated, use script_key_type instead!
    /// Indicates whether the script key is known to have a Tapscript spend path,
    /// meaning that the Taproot merkle root tweak is not empty. This will only
    /// ever be true if either script_key_is_local or script_key_internals_known
    /// is true as well, since the presence of a Tapscript spend path cannot be
    /// determined for script keys that aren't known to the wallet of the local
    /// tapd node.
    #[prost(bool, tag = "19")]
    pub script_key_has_script_path: bool,
    /// This field defines a decimal display value that may be present. If this
    /// field is null, it means the presence of a decimal display field is
    /// unknown in the current context.
    #[prost(message, optional, tag = "20")]
    pub decimal_display: ::core::option::Option<DecimalDisplay>,
    /// The type of the script key. This type is either user-declared when custom
    /// script keys are added, or automatically determined by the daemon for
    /// standard operations (e.g. BIP-86 keys, burn keys, tombstone keys, channel
    /// related keys).
    #[prost(enumeration = "ScriptKeyType", tag = "21")]
    pub script_key_type: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrevWitness {
    #[prost(message, optional, tag = "1")]
    pub prev_id: ::core::option::Option<PrevInputAsset>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub tx_witness: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, optional, tag = "3")]
    pub split_commitment: ::core::option::Option<SplitCommitment>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SplitCommitment {
    #[prost(message, optional, tag = "1")]
    pub root_asset: ::core::option::Option<Asset>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListAssetResponse {
    #[prost(message, repeated, tag = "1")]
    pub assets: ::prost::alloc::vec::Vec<Asset>,
    /// This is a count of unconfirmed outgoing transfers. Unconfirmed transfers
    /// do not appear as assets in this endpoint response.
    #[prost(uint64, tag = "2")]
    pub unconfirmed_transfers: u64,
    /// This is a count of freshly minted assets that haven't been confirmed on
    /// chain yet. These assets will appear in the asset list with a block height
    /// of 0 if include_unconfirmed_mints is set to true in the request.
    #[prost(uint64, tag = "3")]
    pub unconfirmed_mints: u64,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListUtxosRequest {
    #[prost(bool, tag = "1")]
    pub include_leased: bool,
    /// The script key type to filter the assets by. If not set, only assets with
    /// a BIP-0086 script key will be returned (which is the equivalent of
    /// setting script_key_type.explicit_type = SCRIPT_KEY_BIP86).
    #[prost(message, optional, tag = "2")]
    pub script_key_type: ::core::option::Option<ScriptKeyTypeQuery>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ManagedUtxo {
    /// The outpoint of the UTXO.
    #[prost(string, tag = "1")]
    pub out_point: ::prost::alloc::string::String,
    /// The UTXO amount in satoshis.
    #[prost(int64, tag = "2")]
    pub amt_sat: i64,
    /// The internal key used for the on-chain output.
    #[prost(bytes = "vec", tag = "3")]
    pub internal_key: ::prost::alloc::vec::Vec<u8>,
    /// The Taproot Asset root commitment hash.
    #[prost(bytes = "vec", tag = "4")]
    pub taproot_asset_root: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The Taproot merkle root hash committed to by the outpoint of this UTXO.
    /// If there is no Tapscript sibling, this is equal to the Taproot Asset root
    /// commitment hash.
    #[prost(bytes = "vec", tag = "5")]
    pub merkle_root: ::prost::alloc::vec::Vec<u8>,
    /// The assets held at this UTXO.
    #[prost(message, repeated, tag = "6")]
    pub assets: ::prost::alloc::vec::Vec<Asset>,
    /// The lease owner for this UTXO. If blank the UTXO isn't leased.
    #[prost(bytes = "vec", tag = "7")]
    pub lease_owner: ::prost::alloc::vec::Vec<u8>,
    /// The expiry time as a unix time stamp for this lease. If blank the utxo
    /// isn't leased.
    #[prost(int64, tag = "8")]
    pub lease_expiry_unix: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListUtxosResponse {
    /// The set of UTXOs managed by the daemon.
    #[prost(map = "string, message", tag = "1")]
    pub managed_utxos: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        ManagedUtxo,
    >,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ListGroupsRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetHumanReadable {
    /// The ID of the asset.
    #[prost(bytes = "vec", tag = "1")]
    pub id: ::prost::alloc::vec::Vec<u8>,
    /// The amount of the asset.
    #[prost(uint64, tag = "2")]
    pub amount: u64,
    /// An optional locktime, as with Bitcoin transactions.
    #[prost(int32, tag = "3")]
    pub lock_time: i32,
    /// An optional relative locktime, as with Bitcoin transactions.
    #[prost(int32, tag = "4")]
    pub relative_lock_time: i32,
    /// The name of the asset.
    #[prost(string, tag = "5")]
    pub tag: ::prost::alloc::string::String,
    /// The metadata hash of the asset.
    #[prost(bytes = "vec", tag = "6")]
    pub meta_hash: ::prost::alloc::vec::Vec<u8>,
    /// The type of the asset.
    #[prost(enumeration = "AssetType", tag = "7")]
    pub r#type: i32,
    /// The version of the asset.
    #[prost(enumeration = "AssetVersion", tag = "8")]
    pub version: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GroupedAssets {
    /// A list of assets with the same group key.
    #[prost(message, repeated, tag = "1")]
    pub assets: ::prost::alloc::vec::Vec<AssetHumanReadable>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListGroupsResponse {
    /// The set of assets with a group key.
    #[prost(map = "string, message", tag = "1")]
    pub groups: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        GroupedAssets,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBalancesRequest {
    /// If the query results should grouped by asset ids, then an optional asset
    /// filter may be provided to query balance of a specific asset.
    #[prost(bytes = "vec", tag = "3")]
    pub asset_filter: ::prost::alloc::vec::Vec<u8>,
    /// If the query results should be grouped by group keys, then an optional
    /// group key filter may be provided to query the balance of a specific
    /// asset group.
    #[prost(bytes = "vec", tag = "4")]
    pub group_key_filter: ::prost::alloc::vec::Vec<u8>,
    /// An option to include previous leased assets in the balances.
    #[prost(bool, tag = "5")]
    pub include_leased: bool,
    /// The script key type to filter the assets by. If not set, only assets with
    /// a BIP-0086 script key will be returned (which is the equivalent of
    /// setting script_key_type.explicit_type = SCRIPT_KEY_BIP86). If the type
    /// is set to SCRIPT_KEY_BURN or SCRIPT_KEY_TOMBSTONE the include_spent flag
    /// will automatically be set to true, because assets of that type are always
    /// marked as spent.
    #[prost(message, optional, tag = "6")]
    pub script_key_type: ::core::option::Option<ScriptKeyTypeQuery>,
    #[prost(oneof = "list_balances_request::GroupBy", tags = "1, 2")]
    pub group_by: ::core::option::Option<list_balances_request::GroupBy>,
}
/// Nested message and enum types in `ListBalancesRequest`.
pub mod list_balances_request {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum GroupBy {
        /// Group results by asset IDs.
        #[prost(bool, tag = "1")]
        AssetId(bool),
        /// Group results by group keys.
        #[prost(bool, tag = "2")]
        GroupKey(bool),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetBalance {
    /// The base genesis information of an asset. This information never changes.
    #[prost(message, optional, tag = "1")]
    pub asset_genesis: ::core::option::Option<GenesisInfo>,
    /// The balance of the asset owned by the target daemon.
    #[prost(uint64, tag = "3")]
    pub balance: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetGroupBalance {
    /// The group key or nil aggregating assets that don't have a group.
    #[prost(bytes = "vec", tag = "1")]
    pub group_key: ::prost::alloc::vec::Vec<u8>,
    /// The total balance of the assets in the group.
    #[prost(uint64, tag = "2")]
    pub balance: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBalancesResponse {
    #[prost(map = "string, message", tag = "1")]
    pub asset_balances: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AssetBalance,
    >,
    #[prost(map = "string, message", tag = "2")]
    pub asset_group_balances: ::std::collections::HashMap<
        ::prost::alloc::string::String,
        AssetGroupBalance,
    >,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransfersRequest {
    /// anchor_txid specifies the hexadecimal encoded txid string of the anchor
    /// transaction for which to retrieve transfers. An empty value indicates
    /// that this parameter should be disregarded in transfer selection.
    #[prost(string, tag = "1")]
    pub anchor_txid: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListTransfersResponse {
    /// The unordered list of outgoing asset transfers.
    #[prost(message, repeated, tag = "1")]
    pub transfers: ::prost::alloc::vec::Vec<AssetTransfer>,
}
/// ChainHash represents a hash value, typically a double SHA-256 of some data.
/// Common examples include block hashes and transaction hashes.
///
/// This versatile message type is used in various Bitcoin-related messages and
/// structures, providing two different formats of the same hash to accommodate
/// both developer and user needs.
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChainHash {
    /// The raw hash value in byte format.
    ///
    /// This format is optimized for programmatic use, particularly for Go
    /// developers, enabling easy integration with other RPC calls or binary
    /// operations.
    #[prost(bytes = "vec", tag = "1")]
    pub hash: ::prost::alloc::vec::Vec<u8>,
    /// The byte-reversed hash value as a hexadecimal string.
    ///
    /// This format is intended for human interaction, making it easy to copy,
    /// paste, and use in contexts like command-line arguments or configuration
    /// files.
    #[prost(string, tag = "2")]
    pub hash_str: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetTransfer {
    #[prost(int64, tag = "1")]
    pub transfer_timestamp: i64,
    /// The new transaction that commits to the set of Taproot Assets found
    /// at the above new anchor point.
    #[prost(bytes = "vec", tag = "2")]
    pub anchor_tx_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "3")]
    pub anchor_tx_height_hint: u32,
    #[prost(int64, tag = "4")]
    pub anchor_tx_chain_fees: i64,
    /// Describes the set of spent assets.
    #[prost(message, repeated, tag = "5")]
    pub inputs: ::prost::alloc::vec::Vec<TransferInput>,
    /// Describes the set of newly created asset outputs.
    #[prost(message, repeated, tag = "6")]
    pub outputs: ::prost::alloc::vec::Vec<TransferOutput>,
    /// The block hash of the blockchain block that contains the anchor
    /// transaction. If this value is unset, the anchor transaction is
    /// unconfirmed.
    #[prost(message, optional, tag = "7")]
    pub anchor_tx_block_hash: ::core::option::Option<ChainHash>,
    /// The block height of the blockchain block that contains the anchor
    /// transaction. If the anchor transaction is still unconfirmed, this value
    /// will be 0.
    #[prost(uint32, tag = "8")]
    pub anchor_tx_block_height: u32,
    /// An optional short label for the transfer. This label can be used to track
    /// the progress of the transfer via the logs or an event subscription.
    /// Multiple transfers can share the same label.
    #[prost(string, tag = "9")]
    pub label: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferInput {
    /// The old/current location of the Taproot Asset commitment that was spent
    /// as an input.
    #[prost(string, tag = "1")]
    pub anchor_point: ::prost::alloc::string::String,
    /// The ID of the asset that was spent.
    #[prost(bytes = "vec", tag = "2")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    /// The script key of the asset that was spent.
    #[prost(bytes = "vec", tag = "3")]
    pub script_key: ::prost::alloc::vec::Vec<u8>,
    /// The amount of the asset that was spent.
    #[prost(uint64, tag = "4")]
    pub amount: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferOutputAnchor {
    /// The new location of the Taproot Asset commitment that was created on
    /// chain.
    #[prost(string, tag = "1")]
    pub outpoint: ::prost::alloc::string::String,
    #[prost(int64, tag = "2")]
    pub value: i64,
    #[prost(bytes = "vec", tag = "3")]
    pub internal_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub taproot_asset_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "5")]
    pub merkle_root: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub tapscript_sibling: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "7")]
    pub num_passive_assets: u32,
    /// pk_script is the pkscript of the anchor output.
    #[prost(bytes = "vec", tag = "8")]
    pub pk_script: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TransferOutput {
    #[prost(message, optional, tag = "1")]
    pub anchor: ::core::option::Option<TransferOutputAnchor>,
    #[prost(bytes = "vec", tag = "2")]
    pub script_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(bool, tag = "3")]
    pub script_key_is_local: bool,
    #[prost(uint64, tag = "4")]
    pub amount: u64,
    /// The new individual transition proof (not a full proof file) that proves
    /// the inclusion of the new asset within the new AnchorTx.
    #[prost(bytes = "vec", tag = "5")]
    pub new_proof_blob: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "6")]
    pub split_commit_root_hash: ::prost::alloc::vec::Vec<u8>,
    #[prost(enumeration = "OutputType", tag = "7")]
    pub output_type: i32,
    #[prost(enumeration = "AssetVersion", tag = "8")]
    pub asset_version: i32,
    #[prost(uint64, tag = "9")]
    pub lock_time: u64,
    #[prost(uint64, tag = "10")]
    pub relative_lock_time: u64,
    /// The delivery status of the proof associated with this output.
    #[prost(enumeration = "ProofDeliveryStatus", tag = "11")]
    pub proof_delivery_status: i32,
    #[prost(bytes = "vec", tag = "12")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StopRequest {}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct StopResponse {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DebugLevelRequest {
    /// If true, all the valid debug sub-systems will be returned.
    #[prost(bool, tag = "1")]
    pub show: bool,
    #[prost(string, tag = "2")]
    pub level_spec: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DebugLevelResponse {
    #[prost(string, tag = "1")]
    pub sub_systems: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Addr {
    /// The bech32 encoded Taproot Asset address.
    #[prost(string, tag = "1")]
    pub encoded: ::prost::alloc::string::String,
    /// The asset ID that uniquely identifies the asset.
    #[prost(bytes = "vec", tag = "2")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    /// The type of the asset.
    #[prost(enumeration = "AssetType", tag = "3")]
    pub asset_type: i32,
    /// The total amount of the asset stored in this Taproot Asset UTXO.
    #[prost(uint64, tag = "4")]
    pub amount: u64,
    /// The group key of the asset (if it exists)
    #[prost(bytes = "vec", tag = "5")]
    pub group_key: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The specific script key the asset must commit to in order to transfer
    /// ownership to the creator of the address.
    #[prost(bytes = "vec", tag = "6")]
    pub script_key: ::prost::alloc::vec::Vec<u8>,
    /// The internal key used for the on-chain output.
    #[prost(bytes = "vec", tag = "7")]
    pub internal_key: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The optional serialized tapscript sibling preimage to use for the receiving
    /// asset. This is usually empty as it is only needed when there should be an
    /// additional script path in the Taproot tree alongside the Taproot Asset
    /// commitment of the asset.
    #[prost(bytes = "vec", tag = "8")]
    pub tapscript_sibling: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The tweaked internal key that commits to the asset and represents the
    /// on-chain output key the Bitcoin transaction must send to in order to
    /// transfer assets described in this address.
    #[prost(bytes = "vec", tag = "9")]
    pub taproot_output_key: ::prost::alloc::vec::Vec<u8>,
    /// The address of the proof courier service used in proof transfer.
    #[prost(string, tag = "10")]
    pub proof_courier_addr: ::prost::alloc::string::String,
    /// The asset version of the address.
    #[prost(enumeration = "AssetVersion", tag = "11")]
    pub asset_version: i32,
    /// The version of the address.
    #[prost(enumeration = "AddrVersion", tag = "12")]
    pub address_version: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct QueryAddrRequest {
    ///
    /// If set, then only addresses created after this Unix timestamp will be
    /// returned.
    #[prost(int64, tag = "1")]
    pub created_after: i64,
    ///
    /// If set, then only addresses created before this Unix timestamp will be
    /// returned.
    #[prost(int64, tag = "2")]
    pub created_before: i64,
    /// The max number of addresses that should be returned.
    #[prost(int32, tag = "3")]
    pub limit: i32,
    /// The offset from the addresses that should be returned.
    #[prost(int32, tag = "4")]
    pub offset: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueryAddrResponse {
    #[prost(message, repeated, tag = "1")]
    pub addrs: ::prost::alloc::vec::Vec<Addr>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NewAddrRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "2")]
    pub amt: u64,
    ///
    /// The optional script key that the receiving asset should be locked to. If no
    /// script key is provided, a normal BIP-86 key will be derived from the
    /// underlying wallet.
    ///
    /// NOTE: The script_key and internal_key fields should either both be set or
    /// both be empty.
    #[prost(message, optional, tag = "3")]
    pub script_key: ::core::option::Option<ScriptKey>,
    ///
    /// The optional internal key of the receiving BTC level transaction output on
    /// which the receiving asset transfers will be committed to. If no internal key
    /// is provided, a key will be derived from the underlying wallet.
    ///
    /// NOTE: The script_key and internal_key fields should either both be set or
    /// both be empty.
    #[prost(message, optional, tag = "4")]
    pub internal_key: ::core::option::Option<KeyDescriptor>,
    ///
    /// The optional serialized tapscript sibling preimage to use for the receiving
    /// asset. This is usually empty as it is only needed when there should be an
    /// additional script path in the Taproot tree alongside the Taproot Asset
    /// commitment of the asset.
    #[prost(bytes = "vec", tag = "5")]
    pub tapscript_sibling: ::prost::alloc::vec::Vec<u8>,
    ///
    /// An optional proof courier address for use in proof transfer. If unspecified,
    /// the daemon configured default address will be used.
    #[prost(string, tag = "6")]
    pub proof_courier_addr: ::prost::alloc::string::String,
    ///
    /// The asset version to use when sending/receiving to/from this address.
    #[prost(enumeration = "AssetVersion", tag = "7")]
    pub asset_version: i32,
    ///
    /// The version of this address.
    #[prost(enumeration = "AddrVersion", tag = "8")]
    pub address_version: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct ScriptKeyTypeQuery {
    #[prost(oneof = "script_key_type_query::Type", tags = "1, 2")]
    pub r#type: ::core::option::Option<script_key_type_query::Type>,
}
/// Nested message and enum types in `ScriptKeyTypeQuery`.
pub mod script_key_type_query {
    #[derive(Clone, Copy, PartialEq, ::prost::Oneof)]
    pub enum Type {
        /// Query for assets of a specific script key type.
        #[prost(enumeration = "super::ScriptKeyType", tag = "1")]
        ExplicitType(i32),
        /// Query for assets with all script key types.
        #[prost(bool, tag = "2")]
        AllTypes(bool),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ScriptKey {
    ///
    /// The full Taproot output key the asset is locked to. This is either a BIP-86
    /// key if the tap_tweak below is empty, or a key with the tap tweak applied to
    /// it.
    #[prost(bytes = "vec", tag = "1")]
    pub pub_key: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The key descriptor describing the internal key of the above Taproot key.
    #[prost(message, optional, tag = "2")]
    pub key_desc: ::core::option::Option<KeyDescriptor>,
    ///
    /// The optional Taproot tweak to apply to the above internal key. If this is
    /// empty then a BIP-86 style tweak is applied to the internal key.
    #[prost(bytes = "vec", tag = "3")]
    pub tap_tweak: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The type of the script key. This type is either user-declared when custom
    /// script keys are added, or automatically determined by the daemon for
    /// standard operations (e.g. BIP-86 keys, burn keys, tombstone keys, channel
    /// related keys).
    #[prost(enumeration = "ScriptKeyType", tag = "4")]
    pub r#type: i32,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct KeyLocator {
    ///
    /// The family of key being identified.
    #[prost(int32, tag = "1")]
    pub key_family: i32,
    ///
    /// The precise index of the key being identified.
    #[prost(int32, tag = "2")]
    pub key_index: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct KeyDescriptor {
    ///
    /// The raw bytes of the key being identified.
    #[prost(bytes = "vec", tag = "1")]
    pub raw_key_bytes: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The key locator that identifies which key to use for signing.
    #[prost(message, optional, tag = "2")]
    pub key_loc: ::core::option::Option<KeyLocator>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TapscriptFullTree {
    ///
    /// The complete, ordered list of all tap leaves of the tree.
    #[prost(message, repeated, tag = "1")]
    pub all_leaves: ::prost::alloc::vec::Vec<TapLeaf>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TapLeaf {
    /// The script of the tap leaf.
    #[prost(bytes = "vec", tag = "2")]
    pub script: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct TapBranch {
    /// The TapHash of the left child of the root hash of a Tapscript tree.
    #[prost(bytes = "vec", tag = "1")]
    pub left_taphash: ::prost::alloc::vec::Vec<u8>,
    /// The TapHash of the right child of the root hash of a Tapscript tree.
    #[prost(bytes = "vec", tag = "2")]
    pub right_taphash: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecodeAddrRequest {
    #[prost(string, tag = "1")]
    pub addr: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ProofFile {
    /// The raw proof file encoded as bytes. Must be a file and not just an
    /// individual mint/transfer proof.
    #[prost(bytes = "vec", tag = "1")]
    pub raw_proof_file: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag = "2")]
    pub genesis_point: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecodedProof {
    /// The index depth of the decoded proof, with 0 being the latest proof.
    #[prost(uint32, tag = "1")]
    pub proof_at_depth: u32,
    /// The total number of proofs contained in the decoded proof file (this will
    /// always be 1 if a single mint/transition proof was given as the raw_proof
    /// instead of a file).
    #[prost(uint32, tag = "2")]
    pub number_of_proofs: u32,
    /// The asset referenced in the proof.
    #[prost(message, optional, tag = "3")]
    pub asset: ::core::option::Option<Asset>,
    /// The reveal meta data associated with the proof, if available.
    #[prost(message, optional, tag = "4")]
    pub meta_reveal: ::core::option::Option<AssetMeta>,
    /// The merkle proof for AnchorTx used to prove its
    /// inclusion within BlockHeader.
    #[prost(bytes = "vec", tag = "5")]
    pub tx_merkle_proof: ::prost::alloc::vec::Vec<u8>,
    /// The TaprootProof proving the new inclusion of the
    /// resulting asset within AnchorTx.
    #[prost(bytes = "vec", tag = "6")]
    pub inclusion_proof: ::prost::alloc::vec::Vec<u8>,
    /// The set of TaprootProofs proving the exclusion of
    /// the resulting asset from all other Taproot outputs within AnchorTx.
    #[prost(bytes = "vec", repeated, tag = "7")]
    pub exclusion_proofs: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// An optional TaprootProof needed if this asset is
    /// the result of a split. SplitRootProof proves inclusion of the root
    /// asset of the split.
    #[prost(bytes = "vec", tag = "8")]
    pub split_root_proof: ::prost::alloc::vec::Vec<u8>,
    /// The number of additional nested full proofs for any inputs found within
    /// the resulting asset.
    #[prost(uint32, tag = "9")]
    pub num_additional_inputs: u32,
    /// ChallengeWitness is an optional virtual transaction witness that serves
    /// as an ownership proof for the asset. If this is non-nil, then it is a
    /// valid transfer witness for a 1-input, 1-output virtual transaction that
    /// spends the asset in this proof and sends it to the NUMS key, to prove
    /// that the creator of the proof is able to produce a valid signature to
    /// spend the asset.
    #[prost(bytes = "vec", repeated, tag = "10")]
    pub challenge_witness: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// Indicates whether the state transition this proof represents is a burn,
    /// meaning that the assets were provably destroyed and can no longer be
    /// spent.
    #[prost(bool, tag = "11")]
    pub is_burn: bool,
    /// GenesisReveal is an optional field that is the Genesis information for
    /// the asset. This is required for minting proofs.
    #[prost(message, optional, tag = "12")]
    pub genesis_reveal: ::core::option::Option<GenesisReveal>,
    /// GroupKeyReveal is an optional field that includes the information needed
    /// to derive the tweaked group key.
    #[prost(message, optional, tag = "13")]
    pub group_key_reveal: ::core::option::Option<GroupKeyReveal>,
    /// AltLeaves represent data used to construct an Asset commitment, that
    /// will be inserted in the input anchor Tap commitment. These data-carrying
    /// leaves are used for a purpose distinct from representing individual
    /// individual Taproot Assets.
    #[prost(bytes = "vec", tag = "14")]
    pub alt_leaves: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct VerifyProofResponse {
    #[prost(bool, tag = "1")]
    pub valid: bool,
    /// The decoded last proof in the file if the proof file was valid.
    #[prost(message, optional, tag = "2")]
    pub decoded_proof: ::core::option::Option<DecodedProof>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecodeProofRequest {
    /// The raw proof bytes to decode. This can be a full proof file or a single
    /// mint/transition proof. If it is a full proof file, the proof_at_depth
    /// field will be used to determine which individual proof within the file to
    /// decode.
    #[prost(bytes = "vec", tag = "1")]
    pub raw_proof: ::prost::alloc::vec::Vec<u8>,
    /// The index depth of the decoded proof, with 0 being the latest proof. This
    /// is ignored if the raw_proof is a single mint/transition proof and not a
    /// proof file.
    #[prost(uint32, tag = "2")]
    pub proof_at_depth: u32,
    /// An option to include previous witnesses in decoding.
    #[prost(bool, tag = "3")]
    pub with_prev_witnesses: bool,
    /// An option to attempt to retrieve the meta data associated with the proof.
    #[prost(bool, tag = "4")]
    pub with_meta_reveal: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct DecodeProofResponse {
    #[prost(message, optional, tag = "1")]
    pub decoded_proof: ::core::option::Option<DecodedProof>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ExportProofRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub script_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "3")]
    pub outpoint: ::core::option::Option<OutPoint>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnpackProofFileRequest {
    /// The raw proof file encoded as bytes. Must be a file and not just an
    /// individual mint/transfer proof.
    #[prost(bytes = "vec", tag = "1")]
    pub raw_proof_file: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct UnpackProofFileResponse {
    /// The individual proofs contained in the proof file, ordered by their
    /// appearance within the file (issuance proof first, last known transfer
    /// last).
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub raw_proofs: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddrEvent {
    /// The time the event was created in unix timestamp seconds.
    #[prost(uint64, tag = "1")]
    pub creation_time_unix_seconds: u64,
    /// The address the event was created for.
    #[prost(message, optional, tag = "2")]
    pub addr: ::core::option::Option<Addr>,
    /// The current status of the event.
    #[prost(enumeration = "AddrEventStatus", tag = "3")]
    pub status: i32,
    /// The outpoint that contains the inbound asset transfer.
    #[prost(string, tag = "4")]
    pub outpoint: ::prost::alloc::string::String,
    ///
    /// The amount in satoshis that were transferred on chain along with the asset.
    /// This amount is independent of the requested asset amount, which can be
    /// looked up on the address.
    #[prost(uint64, tag = "5")]
    pub utxo_amt_sat: u64,
    ///
    /// The taproot sibling hash that was used to send to the Taproot output.
    #[prost(bytes = "vec", tag = "6")]
    pub taproot_sibling: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The height at which the on-chain output was confirmed. If this is zero, it
    /// means the output is unconfirmed.
    #[prost(uint32, tag = "7")]
    pub confirmation_height: u32,
    ///
    /// Indicates whether a proof file can be found for the address' asset ID and
    /// script key.
    #[prost(bool, tag = "8")]
    pub has_proof: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddrReceivesRequest {
    /// Filter receives by a specific address. Leave empty to get all receives.
    #[prost(string, tag = "1")]
    pub filter_addr: ::prost::alloc::string::String,
    /// Filter receives by a specific status. Leave empty to get all receives.
    #[prost(enumeration = "AddrEventStatus", tag = "2")]
    pub filter_status: i32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddrReceivesResponse {
    /// The events that match the filter criteria.
    #[prost(message, repeated, tag = "1")]
    pub events: ::prost::alloc::vec::Vec<AddrEvent>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendAssetRequest {
    #[prost(string, repeated, tag = "1")]
    pub tap_addrs: ::prost::alloc::vec::Vec<::prost::alloc::string::String>,
    /// The optional fee rate to use for the minting transaction, in sat/kw.
    ///
    /// TODO(roasbeef): maybe in future add details re type of ProofCourier or
    /// w/e
    #[prost(uint32, tag = "2")]
    pub fee_rate: u32,
    /// An optional short label for the send transfer. This label can be used to
    /// track the progress of the transfer via the logs or an event subscription.
    /// Multiple transfers can share the same label.
    #[prost(string, tag = "3")]
    pub label: ::prost::alloc::string::String,
    /// A flag to skip the proof courier ping check. This is useful for
    /// testing purposes and for forced transfers when the proof courier
    /// is not immediately available.
    #[prost(bool, tag = "4")]
    pub skip_proof_courier_ping_check: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PrevInputAsset {
    #[prost(string, tag = "1")]
    pub anchor_point: ::prost::alloc::string::String,
    #[prost(bytes = "vec", tag = "2")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub script_key: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint64, tag = "4")]
    pub amount: u64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendAssetResponse {
    #[prost(message, optional, tag = "1")]
    pub transfer: ::core::option::Option<AssetTransfer>,
}
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct GetInfoRequest {}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetInfoResponse {
    #[prost(string, tag = "1")]
    pub version: ::prost::alloc::string::String,
    #[prost(string, tag = "2")]
    pub lnd_version: ::prost::alloc::string::String,
    #[prost(string, tag = "3")]
    pub network: ::prost::alloc::string::String,
    #[prost(string, tag = "4")]
    pub lnd_identity_pubkey: ::prost::alloc::string::String,
    #[prost(string, tag = "5")]
    pub node_alias: ::prost::alloc::string::String,
    #[prost(uint32, tag = "6")]
    pub block_height: u32,
    #[prost(string, tag = "7")]
    pub block_hash: ::prost::alloc::string::String,
    #[prost(bool, tag = "8")]
    pub sync_to_chain: bool,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct FetchAssetMetaRequest {
    #[prost(oneof = "fetch_asset_meta_request::Asset", tags = "1, 2, 3, 4")]
    pub asset: ::core::option::Option<fetch_asset_meta_request::Asset>,
}
/// Nested message and enum types in `FetchAssetMetaRequest`.
pub mod fetch_asset_meta_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Asset {
        /// The asset ID of the asset to fetch the meta for.
        #[prost(bytes, tag = "1")]
        AssetId(::prost::alloc::vec::Vec<u8>),
        /// The 32-byte meta hash of the asset meta.
        #[prost(bytes, tag = "2")]
        MetaHash(::prost::alloc::vec::Vec<u8>),
        /// The hex encoded asset ID of the asset to fetch the meta for.
        #[prost(string, tag = "3")]
        AssetIdStr(::prost::alloc::string::String),
        /// The hex encoded meta hash of the asset meta.
        #[prost(string, tag = "4")]
        MetaHashStr(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BurnAssetRequest {
    #[prost(uint64, tag = "3")]
    pub amount_to_burn: u64,
    /// A safety check to ensure the user is aware of the destructive nature of
    /// the burn. This needs to be set to the value "assets will be destroyed"
    /// for the burn to succeed.
    #[prost(string, tag = "4")]
    pub confirmation_text: ::prost::alloc::string::String,
    /// A note that may contain user defined metadata related to this burn.
    #[prost(string, tag = "5")]
    pub note: ::prost::alloc::string::String,
    #[prost(oneof = "burn_asset_request::Asset", tags = "1, 2")]
    pub asset: ::core::option::Option<burn_asset_request::Asset>,
}
/// Nested message and enum types in `BurnAssetRequest`.
pub mod burn_asset_request {
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Asset {
        /// The asset ID of the asset to burn units of.
        #[prost(bytes, tag = "1")]
        AssetId(::prost::alloc::vec::Vec<u8>),
        /// The hex encoded asset ID of the asset to burn units of.
        #[prost(string, tag = "2")]
        AssetIdStr(::prost::alloc::string::String),
    }
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BurnAssetResponse {
    /// The asset transfer that contains the asset burn as an output.
    #[prost(message, optional, tag = "1")]
    pub burn_transfer: ::core::option::Option<AssetTransfer>,
    /// The burn transition proof for the asset burn output.
    #[prost(message, optional, tag = "2")]
    pub burn_proof: ::core::option::Option<DecodedProof>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBurnsRequest {
    /// The asset id of the burnt asset.
    #[prost(bytes = "vec", tag = "1")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    /// The tweaked group key of the group this asset belongs to.
    #[prost(bytes = "vec", tag = "3")]
    pub tweaked_group_key: ::prost::alloc::vec::Vec<u8>,
    /// The txid of the transaction that the burn was anchored to.
    #[prost(bytes = "vec", tag = "4")]
    pub anchor_txid: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AssetBurn {
    /// A note that may contain user defined metadata related to this burn.
    #[prost(string, tag = "1")]
    pub note: ::prost::alloc::string::String,
    /// The asset id of the burnt asset.
    #[prost(bytes = "vec", tag = "2")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    /// The tweaked group key of the group this asset belongs to.
    #[prost(bytes = "vec", tag = "3")]
    pub tweaked_group_key: ::prost::alloc::vec::Vec<u8>,
    /// The amount of burnt assets.
    #[prost(uint64, tag = "4")]
    pub amount: u64,
    /// The txid of the transaction that the burn was anchored to.
    #[prost(bytes = "vec", tag = "5")]
    pub anchor_txid: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ListBurnsResponse {
    #[prost(message, repeated, tag = "1")]
    pub burns: ::prost::alloc::vec::Vec<AssetBurn>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct OutPoint {
    ///
    /// Raw bytes representing the transaction id.
    #[prost(bytes = "vec", tag = "1")]
    pub txid: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The index of the output on the transaction.
    #[prost(uint32, tag = "2")]
    pub output_index: u32,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeReceiveEventsRequest {
    /// Filter receives by a specific address. Leave empty to get all receive
    /// events for all addresses.
    #[prost(string, tag = "1")]
    pub filter_addr: ::prost::alloc::string::String,
    /// The start time as a Unix timestamp in microseconds. If not set (default
    /// value 0), the daemon will start streaming events from the current time.
    #[prost(int64, tag = "2")]
    pub start_timestamp: i64,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReceiveEvent {
    /// Event creation timestamp (Unix timestamp in microseconds).
    #[prost(int64, tag = "1")]
    pub timestamp: i64,
    /// The address that received the asset.
    #[prost(message, optional, tag = "2")]
    pub address: ::core::option::Option<Addr>,
    /// The outpoint of the transaction that was used to receive the asset.
    #[prost(string, tag = "3")]
    pub outpoint: ::prost::alloc::string::String,
    /// The status of the event. If error below is set, then the status is the
    /// state that lead to the error during its execution.
    #[prost(enumeration = "AddrEventStatus", tag = "4")]
    pub status: i32,
    /// The height of the block the asset receive transaction was mined in. This
    /// is only set if the status is ADDR_EVENT_STATUS_TRANSACTION_CONFIRMED or
    /// later.
    #[prost(uint32, tag = "5")]
    pub confirmation_height: u32,
    /// An optional error, indicating that executing the status above failed.
    #[prost(string, tag = "6")]
    pub error: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SubscribeSendEventsRequest {
    /// Filter send events by a specific recipient script key. Leave empty to get
    /// all receive events for all parcels.
    #[prost(bytes = "vec", tag = "1")]
    pub filter_script_key: ::prost::alloc::vec::Vec<u8>,
    /// Filter send events by a specific label. Leave empty to not filter by
    /// transfer label.
    #[prost(string, tag = "2")]
    pub filter_label: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct SendEvent {
    /// Execute timestamp (Unix timestamp in microseconds).
    #[prost(int64, tag = "1")]
    pub timestamp: i64,
    /// The send state that was executed successfully. If error below is set,
    /// then the send_state is the state that lead to the error during its
    /// execution.
    #[prost(string, tag = "2")]
    pub send_state: ::prost::alloc::string::String,
    /// The type of the outbound send parcel.
    #[prost(enumeration = "ParcelType", tag = "3")]
    pub parcel_type: i32,
    /// The list of addresses the parcel sends to (recipient addresses only, not
    /// including change going back to own wallet). This is only set for parcels
    /// of type PARCEL_TYPE_ADDRESS.
    #[prost(message, repeated, tag = "4")]
    pub addresses: ::prost::alloc::vec::Vec<Addr>,
    /// The virtual packets that are part of the parcel.
    #[prost(bytes = "vec", repeated, tag = "5")]
    pub virtual_packets: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// The passive virtual packets that are carried along with the parcel. This
    /// is empty if there were no other assets in the input commitment that is
    /// being spent with the "active" virtual packets above.
    #[prost(bytes = "vec", repeated, tag = "6")]
    pub passive_virtual_packets: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    /// The Bitcoin on-chain anchor transaction that commits the sent assets
    /// on-chain. This is only set after the send state SEND_STATE_ANCHOR_SIGN.
    #[prost(message, optional, tag = "7")]
    pub anchor_transaction: ::core::option::Option<AnchorTransaction>,
    /// The final transfer as it will be stored in the database. This is only set
    /// after the send state SEND_STATE_LOG_COMMITMENT.
    #[prost(message, optional, tag = "8")]
    pub transfer: ::core::option::Option<AssetTransfer>,
    /// An optional error, indicating that executing the send_state failed.
    #[prost(string, tag = "9")]
    pub error: ::prost::alloc::string::String,
    /// The label of the transfer.
    #[prost(string, tag = "10")]
    pub transfer_label: ::prost::alloc::string::String,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AnchorTransaction {
    #[prost(bytes = "vec", tag = "1")]
    pub anchor_psbt: ::prost::alloc::vec::Vec<u8>,
    ///
    /// The index of the (added) change output or -1 if no change was left over.
    #[prost(int32, tag = "2")]
    pub change_output_index: i32,
    ///
    /// The total number of satoshis in on-chain fees paid by the anchor
    /// transaction.
    #[prost(int64, tag = "3")]
    pub chain_fees_sats: i64,
    ///
    /// The fee rate in sat/kWU that was targeted by the anchor transaction.
    #[prost(int32, tag = "4")]
    pub target_fee_rate_sat_kw: i32,
    ///
    /// The list of UTXO lock leases that were acquired for the inputs in the funded
    /// PSBT packet from lnd. Only inputs added to the PSBT by this RPC are locked,
    /// inputs that were already present in the PSBT are not locked.
    #[prost(message, repeated, tag = "5")]
    pub lnd_locked_utxos: ::prost::alloc::vec::Vec<OutPoint>,
    ///
    /// The final, signed anchor transaction that was broadcast to the network.
    #[prost(bytes = "vec", tag = "6")]
    pub final_tx: ::prost::alloc::vec::Vec<u8>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterTransferRequest {
    /// The asset ID of the asset to register the transfer for.
    #[prost(bytes = "vec", tag = "1")]
    pub asset_id: ::prost::alloc::vec::Vec<u8>,
    /// The optional group key of the asset to register the transfer for.
    #[prost(bytes = "vec", tag = "2")]
    pub group_key: ::prost::alloc::vec::Vec<u8>,
    /// The script key of the asset to register the transfer for.
    #[prost(bytes = "vec", tag = "3")]
    pub script_key: ::prost::alloc::vec::Vec<u8>,
    /// The outpoint of the transaction that was used to receive the asset.
    #[prost(message, optional, tag = "4")]
    pub outpoint: ::core::option::Option<OutPoint>,
}
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct RegisterTransferResponse {
    #[prost(message, optional, tag = "1")]
    pub registered_asset: ::core::option::Option<Asset>,
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AssetType {
    ///
    /// Indicates that an asset is capable of being split/merged, with each of the
    /// units being fungible, even across a key asset ID boundary (assuming the
    /// key group is the same).
    Normal = 0,
    ///
    /// Indicates that an asset is a collectible, meaning that each of the other
    /// items under the same key group are not fully fungible with each other.
    /// Collectibles also cannot be split or merged.
    Collectible = 1,
}
impl AssetType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Normal => "NORMAL",
            Self::Collectible => "COLLECTIBLE",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "NORMAL" => Some(Self::Normal),
            "COLLECTIBLE" => Some(Self::Collectible),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AssetMetaType {
    ///
    /// Opaque is used for asset meta blobs that have no true structure and instead
    /// should be interpreted as opaque blobs.
    MetaTypeOpaque = 0,
    ///
    /// JSON is used for asset meta blobs that are to be interpreted as valid JSON
    /// strings.
    MetaTypeJson = 1,
}
impl AssetMetaType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::MetaTypeOpaque => "META_TYPE_OPAQUE",
            Self::MetaTypeJson => "META_TYPE_JSON",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "META_TYPE_OPAQUE" => Some(Self::MetaTypeOpaque),
            "META_TYPE_JSON" => Some(Self::MetaTypeJson),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AssetVersion {
    /// ASSET_VERSION_V0 is the default asset version. This version will include
    /// the witness vector in the leaf for a tap commitment.
    V0 = 0,
    /// ASSET_VERSION_V1 is the asset version that leaves out the witness vector
    /// from the MS-SMT leaf encoding.
    V1 = 1,
}
impl AssetVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::V0 => "ASSET_VERSION_V0",
            Self::V1 => "ASSET_VERSION_V1",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ASSET_VERSION_V0" => Some(Self::V0),
            "ASSET_VERSION_V1" => Some(Self::V1),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum OutputType {
    /// OUTPUT_TYPE_SIMPLE is a plain full-value or split output that is not a
    /// split root and does not carry passive assets. In case of a split, the
    /// asset of this output has a split commitment.
    Simple = 0,
    /// OUTPUT_TYPE_SPLIT_ROOT is a split root output that carries the change
    /// from a split or a tombstone from a non-interactive full value send
    /// output. In either case, the asset of this output has a tx witness.
    SplitRoot = 1,
}
impl OutputType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Simple => "OUTPUT_TYPE_SIMPLE",
            Self::SplitRoot => "OUTPUT_TYPE_SPLIT_ROOT",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "OUTPUT_TYPE_SIMPLE" => Some(Self::Simple),
            "OUTPUT_TYPE_SPLIT_ROOT" => Some(Self::SplitRoot),
            _ => None,
        }
    }
}
/// ProofDeliveryStatus is an enum that describes the status of the delivery of
/// a proof associated with an asset transfer output.
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ProofDeliveryStatus {
    /// Delivery is not applicable; the proof will not be delivered.
    NotApplicable = 0,
    /// The proof has been successfully delivered.
    Complete = 1,
    /// The proof is pending delivery. This status indicates that the proof has
    /// not yet been delivered successfully. One or more attempts at proof
    /// delivery may have been made.
    Pending = 2,
}
impl ProofDeliveryStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::NotApplicable => "PROOF_DELIVERY_STATUS_NOT_APPLICABLE",
            Self::Complete => "PROOF_DELIVERY_STATUS_COMPLETE",
            Self::Pending => "PROOF_DELIVERY_STATUS_PENDING",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PROOF_DELIVERY_STATUS_NOT_APPLICABLE" => Some(Self::NotApplicable),
            "PROOF_DELIVERY_STATUS_COMPLETE" => Some(Self::Complete),
            "PROOF_DELIVERY_STATUS_PENDING" => Some(Self::Pending),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AddrVersion {
    /// ADDR_VERSION_UNSPECIFIED is the default value for an address version in
    /// an RPC message. It is unmarshalled to the latest address version.
    Unspecified = 0,
    /// ADDR_VERSION_V0 is the initial address version.
    V0 = 1,
    /// ADDR_VERSION_V1 is the address version that uses V2 Taproot Asset
    /// commitments.
    V1 = 2,
}
impl AddrVersion {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unspecified => "ADDR_VERSION_UNSPECIFIED",
            Self::V0 => "ADDR_VERSION_V0",
            Self::V1 => "ADDR_VERSION_V1",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ADDR_VERSION_UNSPECIFIED" => Some(Self::Unspecified),
            "ADDR_VERSION_V0" => Some(Self::V0),
            "ADDR_VERSION_V1" => Some(Self::V1),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ScriptKeyType {
    ///
    /// The type of script key is not known. This should only be stored for assets
    /// where we don't know the internal key of the script key (e.g. for
    /// imported proofs).
    ScriptKeyUnknown = 0,
    ///
    /// The script key is a normal BIP-86 key. This means that the internal key is
    /// turned into a Taproot output key by applying a BIP-86 tweak to it.
    ScriptKeyBip86 = 1,
    ///
    /// The script key is a key that contains a script path that is defined by the
    /// user and is therefore external to the tapd wallet. Spending this key
    /// requires providing a specific witness and must be signed through the vPSBT
    /// signing flow.
    ScriptKeyScriptPathExternal = 2,
    ///
    /// The script key is a specific un-spendable key that indicates a burnt asset.
    /// Assets with this key type can never be spent again, as a burn key is a
    /// tweaked NUMS key that nobody knows the private key for.
    ScriptKeyBurn = 3,
    ///
    /// The script key is a specific un-spendable key that indicates a tombstone
    /// output. This is only the case for zero-value assets that result from a
    /// non-interactive (TAP address) send where no change was left over.
    ScriptKeyTombstone = 4,
    ///
    /// The script key is used for an asset that resides within a Taproot Asset
    /// Channel. That means the script key is either a funding key (OP_TRUE), a
    /// commitment output key (to_local, to_remote, htlc), or a HTLC second-level
    /// transaction output key. Keys related to channels are not shown in asset
    /// balances (unless specifically requested) and are never used for coin
    /// selection.
    ScriptKeyChannel = 5,
}
impl ScriptKeyType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::ScriptKeyUnknown => "SCRIPT_KEY_UNKNOWN",
            Self::ScriptKeyBip86 => "SCRIPT_KEY_BIP86",
            Self::ScriptKeyScriptPathExternal => "SCRIPT_KEY_SCRIPT_PATH_EXTERNAL",
            Self::ScriptKeyBurn => "SCRIPT_KEY_BURN",
            Self::ScriptKeyTombstone => "SCRIPT_KEY_TOMBSTONE",
            Self::ScriptKeyChannel => "SCRIPT_KEY_CHANNEL",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SCRIPT_KEY_UNKNOWN" => Some(Self::ScriptKeyUnknown),
            "SCRIPT_KEY_BIP86" => Some(Self::ScriptKeyBip86),
            "SCRIPT_KEY_SCRIPT_PATH_EXTERNAL" => Some(Self::ScriptKeyScriptPathExternal),
            "SCRIPT_KEY_BURN" => Some(Self::ScriptKeyBurn),
            "SCRIPT_KEY_TOMBSTONE" => Some(Self::ScriptKeyTombstone),
            "SCRIPT_KEY_CHANNEL" => Some(Self::ScriptKeyChannel),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum AddrEventStatus {
    Unknown = 0,
    TransactionDetected = 1,
    TransactionConfirmed = 2,
    ProofReceived = 3,
    Completed = 4,
}
impl AddrEventStatus {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Unknown => "ADDR_EVENT_STATUS_UNKNOWN",
            Self::TransactionDetected => "ADDR_EVENT_STATUS_TRANSACTION_DETECTED",
            Self::TransactionConfirmed => "ADDR_EVENT_STATUS_TRANSACTION_CONFIRMED",
            Self::ProofReceived => "ADDR_EVENT_STATUS_PROOF_RECEIVED",
            Self::Completed => "ADDR_EVENT_STATUS_COMPLETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "ADDR_EVENT_STATUS_UNKNOWN" => Some(Self::Unknown),
            "ADDR_EVENT_STATUS_TRANSACTION_DETECTED" => Some(Self::TransactionDetected),
            "ADDR_EVENT_STATUS_TRANSACTION_CONFIRMED" => Some(Self::TransactionConfirmed),
            "ADDR_EVENT_STATUS_PROOF_RECEIVED" => Some(Self::ProofReceived),
            "ADDR_EVENT_STATUS_COMPLETED" => Some(Self::Completed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum SendState {
    /// Input coin selection to pick out which asset inputs should be spent is
    /// executed during this state.
    VirtualInputSelect = 0,
    /// The virtual transaction is signed during this state.
    VirtualSign = 1,
    /// The Bitcoin anchor transaction is signed during this state.
    AnchorSign = 2,
    /// The outbound packet is written to the database during this state,
    /// including the partial proof suffixes. Only parcels that complete this
    /// state can be resumed on restart.
    LogCommitment = 3,
    /// The Bitcoin anchor transaction is broadcast to the network during this
    /// state.
    Broadcast = 4,
    /// The on-chain anchor transaction needs to reach at least 1 confirmation.
    /// This state waits for the confirmation.
    WaitConfirmation = 5,
    /// The anchor transaction was confirmed in a block and the full proofs can
    /// now be constructed during this stage.
    StoreProofs = 6,
    /// The full proofs are sent to the recipient(s) with the proof courier
    /// service during this state.
    TransferProofs = 7,
    /// The send state machine has completed the send process.
    Completed = 8,
}
impl SendState {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::VirtualInputSelect => "SEND_STATE_VIRTUAL_INPUT_SELECT",
            Self::VirtualSign => "SEND_STATE_VIRTUAL_SIGN",
            Self::AnchorSign => "SEND_STATE_ANCHOR_SIGN",
            Self::LogCommitment => "SEND_STATE_LOG_COMMITMENT",
            Self::Broadcast => "SEND_STATE_BROADCAST",
            Self::WaitConfirmation => "SEND_STATE_WAIT_CONFIRMATION",
            Self::StoreProofs => "SEND_STATE_STORE_PROOFS",
            Self::TransferProofs => "SEND_STATE_TRANSFER_PROOFS",
            Self::Completed => "SEND_STATE_COMPLETED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "SEND_STATE_VIRTUAL_INPUT_SELECT" => Some(Self::VirtualInputSelect),
            "SEND_STATE_VIRTUAL_SIGN" => Some(Self::VirtualSign),
            "SEND_STATE_ANCHOR_SIGN" => Some(Self::AnchorSign),
            "SEND_STATE_LOG_COMMITMENT" => Some(Self::LogCommitment),
            "SEND_STATE_BROADCAST" => Some(Self::Broadcast),
            "SEND_STATE_WAIT_CONFIRMATION" => Some(Self::WaitConfirmation),
            "SEND_STATE_STORE_PROOFS" => Some(Self::StoreProofs),
            "SEND_STATE_TRANSFER_PROOFS" => Some(Self::TransferProofs),
            "SEND_STATE_COMPLETED" => Some(Self::Completed),
            _ => None,
        }
    }
}
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
#[repr(i32)]
pub enum ParcelType {
    /// The parcel is an address parcel.
    Address = 0,
    /// The parcel type is a pre-signed parcel where the virtual transactions are
    /// signed outside of the send state machine. Parcels of this type will only
    /// get send states starting from SEND_STATE_ANCHOR_SIGN.
    PreSigned = 1,
    /// The parcel is pending and was resumed on the latest restart of the
    /// daemon. The original parcel type (address or pre-signed) is not known
    /// anymore, as it's not relevant for the remaining steps. Parcels of this
    /// type will only get send states starting from SEND_STATE_BROADCAST.
    Pending = 2,
    /// The parcel type is a pre-anchored parcel where the full anchor
    /// transaction and all proofs are already available. Parcels of this type
    /// will only get send states starting from SEND_STATE_LOG_COMMITMENT.
    PreAnchored = 3,
}
impl ParcelType {
    /// String value of the enum field names used in the ProtoBuf definition.
    ///
    /// The values are not transformed in any way and thus are considered stable
    /// (if the ProtoBuf definition does not change) and safe for programmatic use.
    pub fn as_str_name(&self) -> &'static str {
        match self {
            Self::Address => "PARCEL_TYPE_ADDRESS",
            Self::PreSigned => "PARCEL_TYPE_PRE_SIGNED",
            Self::Pending => "PARCEL_TYPE_PENDING",
            Self::PreAnchored => "PARCEL_TYPE_PRE_ANCHORED",
        }
    }
    /// Creates an enum from field names used in the ProtoBuf definition.
    pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
        match value {
            "PARCEL_TYPE_ADDRESS" => Some(Self::Address),
            "PARCEL_TYPE_PRE_SIGNED" => Some(Self::PreSigned),
            "PARCEL_TYPE_PENDING" => Some(Self::Pending),
            "PARCEL_TYPE_PRE_ANCHORED" => Some(Self::PreAnchored),
            _ => None,
        }
    }
}
/// Generated client implementations.
pub mod taproot_assets_client {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    #[derive(Debug, Clone)]
    pub struct TaprootAssetsClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl TaprootAssetsClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> TaprootAssetsClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::Body>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + std::marker::Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + std::marker::Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> TaprootAssetsClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::Body>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::Body>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::Body>,
            >>::Error: Into<StdError> + std::marker::Send + std::marker::Sync,
        {
            TaprootAssetsClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        /// tapcli: `assets list`
        /// ListAssets lists the set of assets owned by the target daemon.
        pub async fn list_assets(
            &mut self,
            request: impl tonic::IntoRequest<super::ListAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAssetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/ListAssets",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "ListAssets"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `assets utxos`
        /// ListUtxos lists the UTXOs managed by the target daemon, and the assets they
        /// hold.
        pub async fn list_utxos(
            &mut self,
            request: impl tonic::IntoRequest<super::ListUtxosRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUtxosResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/ListUtxos",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "ListUtxos"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `assets groups`
        /// ListGroups lists the asset groups known to the target daemon, and the assets
        /// held in each group.
        pub async fn list_groups(
            &mut self,
            request: impl tonic::IntoRequest<super::ListGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListGroupsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/ListGroups",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "ListGroups"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `assets balance`
        /// ListBalances lists asset balances
        pub async fn list_balances(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBalancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBalancesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/ListBalances",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "ListBalances"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `assets transfers`
        /// ListTransfers lists outbound asset transfers tracked by the target daemon.
        pub async fn list_transfers(
            &mut self,
            request: impl tonic::IntoRequest<super::ListTransfersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTransfersResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/ListTransfers",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "ListTransfers"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `stop`
        /// StopDaemon will send a shutdown request to the interrupt handler, triggering
        /// a graceful shutdown of the daemon.
        pub async fn stop_daemon(
            &mut self,
            request: impl tonic::IntoRequest<super::StopRequest>,
        ) -> std::result::Result<tonic::Response<super::StopResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/StopDaemon",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "StopDaemon"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `debuglevel`
        /// DebugLevel allows a caller to programmatically set the logging verbosity of
        /// tapd. The logging can be targeted according to a coarse daemon-wide logging
        /// level, or in a granular fashion to specify the logging for a target
        /// sub-system.
        pub async fn debug_level(
            &mut self,
            request: impl tonic::IntoRequest<super::DebugLevelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DebugLevelResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/DebugLevel",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "DebugLevel"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `addrs query`
        /// QueryAddrs queries the set of Taproot Asset addresses stored in the
        /// database.
        pub async fn query_addrs(
            &mut self,
            request: impl tonic::IntoRequest<super::QueryAddrRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAddrResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/QueryAddrs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "QueryAddrs"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `addrs new`
        /// NewAddr makes a new address from the set of request params.
        pub async fn new_addr(
            &mut self,
            request: impl tonic::IntoRequest<super::NewAddrRequest>,
        ) -> std::result::Result<tonic::Response<super::Addr>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/NewAddr",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "NewAddr"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `addrs decode`
        /// DecodeAddr decode a Taproot Asset address into a partial asset message that
        /// represents the asset it wants to receive.
        pub async fn decode_addr(
            &mut self,
            request: impl tonic::IntoRequest<super::DecodeAddrRequest>,
        ) -> std::result::Result<tonic::Response<super::Addr>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/DecodeAddr",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "DecodeAddr"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `addrs receives`
        /// List all receives for incoming asset transfers for addresses that were
        /// created previously.
        pub async fn addr_receives(
            &mut self,
            request: impl tonic::IntoRequest<super::AddrReceivesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddrReceivesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/AddrReceives",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "AddrReceives"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `proofs verify`
        /// VerifyProof attempts to verify a given proof file that claims to be anchored
        /// at the specified genesis point.
        pub async fn verify_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::ProofFile>,
        ) -> std::result::Result<
            tonic::Response<super::VerifyProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/VerifyProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "VerifyProof"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `proofs decode`
        /// DecodeProof attempts to decode a given proof file into human readable
        /// format.
        pub async fn decode_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::DecodeProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DecodeProofResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/DecodeProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "DecodeProof"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `proofs export`
        /// ExportProof exports the latest raw proof file anchored at the specified
        /// script_key.
        pub async fn export_proof(
            &mut self,
            request: impl tonic::IntoRequest<super::ExportProofRequest>,
        ) -> std::result::Result<tonic::Response<super::ProofFile>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/ExportProof",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "ExportProof"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `proofs unpack`
        /// UnpackProofFile unpacks a proof file into a list of the individual raw
        /// proofs in the proof chain.
        pub async fn unpack_proof_file(
            &mut self,
            request: impl tonic::IntoRequest<super::UnpackProofFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnpackProofFileResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/UnpackProofFile",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "UnpackProofFile"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `assets send`
        /// SendAsset uses one or multiple passed Taproot Asset address(es) to attempt
        /// to complete an asset send. The method returns information w.r.t the on chain
        /// send, as well as the proof file information the receiver needs to fully
        /// receive the asset.
        pub async fn send_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::SendAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SendAssetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/SendAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "SendAsset"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `assets burn`
        /// BurnAsset burns the given number of units of a given asset by sending them
        /// to a provably un-spendable script key. Burning means irrevocably destroying
        /// a certain number of assets, reducing the total supply of the asset. Because
        /// burning is such a destructive and non-reversible operation, some specific
        /// values need to be set in the request to avoid accidental burns.
        pub async fn burn_asset(
            &mut self,
            request: impl tonic::IntoRequest<super::BurnAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BurnAssetResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/BurnAsset",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "BurnAsset"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `assets listburns`
        /// ListBurns lists the asset burns that this wallet has performed. These assets
        /// are not recoverable in any way. Filters may be applied to return more
        /// specific results.
        pub async fn list_burns(
            &mut self,
            request: impl tonic::IntoRequest<super::ListBurnsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBurnsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/ListBurns",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "ListBurns"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `getinfo`
        /// GetInfo returns the information for the node.
        pub async fn get_info(
            &mut self,
            request: impl tonic::IntoRequest<super::GetInfoRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetInfoResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/GetInfo",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "GetInfo"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `assets meta`
        /// FetchAssetMeta allows a caller to fetch the reveal meta data for an asset
        /// either by the asset ID for that asset, or a meta hash.
        pub async fn fetch_asset_meta(
            &mut self,
            request: impl tonic::IntoRequest<super::FetchAssetMetaRequest>,
        ) -> std::result::Result<tonic::Response<super::AssetMeta>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/FetchAssetMeta",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "FetchAssetMeta"));
            self.inner.unary(req, path, codec).await
        }
        /// tapcli: `events receive`
        /// SubscribeReceiveEvents allows a caller to subscribe to receive events for
        /// incoming asset transfers.
        pub async fn subscribe_receive_events(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeReceiveEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::ReceiveEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/SubscribeReceiveEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("taprpc.TaprootAssets", "SubscribeReceiveEvents"),
                );
            self.inner.server_streaming(req, path, codec).await
        }
        /// tapcli: `events send`
        /// SubscribeSendEvents allows a caller to subscribe to send events for outgoing
        /// asset transfers.
        pub async fn subscribe_send_events(
            &mut self,
            request: impl tonic::IntoRequest<super::SubscribeSendEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::SendEvent>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/SubscribeSendEvents",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "SubscribeSendEvents"));
            self.inner.server_streaming(req, path, codec).await
        }
        ///
        /// RegisterTransfer informs the daemon about a new inbound transfer that has
        /// happened. This is used for interactive transfers where no TAP address is
        /// involved and the recipient is aware of the transfer through an out-of-band
        /// protocol but the daemon hasn't been informed about the completion of the
        /// transfer. For this to work, the proof must already be in the recipient's
        /// local universe (e.g. through the use of the universerpc.InsertProof RPC or
        /// the universe proof courier and universe sync mechanisms) and this call
        /// simply instructs the daemon to detect the transfer as an asset it owns.
        pub async fn register_transfer(
            &mut self,
            request: impl tonic::IntoRequest<super::RegisterTransferRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterTransferResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::unknown(
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/taprpc.TaprootAssets/RegisterTransfer",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("taprpc.TaprootAssets", "RegisterTransfer"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod taproot_assets_server {
    #![allow(
        unused_variables,
        dead_code,
        missing_docs,
        clippy::wildcard_imports,
        clippy::let_unit_value,
    )]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with TaprootAssetsServer.
    #[async_trait]
    pub trait TaprootAssets: std::marker::Send + std::marker::Sync + 'static {
        /// tapcli: `assets list`
        /// ListAssets lists the set of assets owned by the target daemon.
        async fn list_assets(
            &self,
            request: tonic::Request<super::ListAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListAssetResponse>,
            tonic::Status,
        >;
        /// tapcli: `assets utxos`
        /// ListUtxos lists the UTXOs managed by the target daemon, and the assets they
        /// hold.
        async fn list_utxos(
            &self,
            request: tonic::Request<super::ListUtxosRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListUtxosResponse>,
            tonic::Status,
        >;
        /// tapcli: `assets groups`
        /// ListGroups lists the asset groups known to the target daemon, and the assets
        /// held in each group.
        async fn list_groups(
            &self,
            request: tonic::Request<super::ListGroupsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListGroupsResponse>,
            tonic::Status,
        >;
        /// tapcli: `assets balance`
        /// ListBalances lists asset balances
        async fn list_balances(
            &self,
            request: tonic::Request<super::ListBalancesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBalancesResponse>,
            tonic::Status,
        >;
        /// tapcli: `assets transfers`
        /// ListTransfers lists outbound asset transfers tracked by the target daemon.
        async fn list_transfers(
            &self,
            request: tonic::Request<super::ListTransfersRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListTransfersResponse>,
            tonic::Status,
        >;
        /// tapcli: `stop`
        /// StopDaemon will send a shutdown request to the interrupt handler, triggering
        /// a graceful shutdown of the daemon.
        async fn stop_daemon(
            &self,
            request: tonic::Request<super::StopRequest>,
        ) -> std::result::Result<tonic::Response<super::StopResponse>, tonic::Status>;
        /// tapcli: `debuglevel`
        /// DebugLevel allows a caller to programmatically set the logging verbosity of
        /// tapd. The logging can be targeted according to a coarse daemon-wide logging
        /// level, or in a granular fashion to specify the logging for a target
        /// sub-system.
        async fn debug_level(
            &self,
            request: tonic::Request<super::DebugLevelRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DebugLevelResponse>,
            tonic::Status,
        >;
        /// tapcli: `addrs query`
        /// QueryAddrs queries the set of Taproot Asset addresses stored in the
        /// database.
        async fn query_addrs(
            &self,
            request: tonic::Request<super::QueryAddrRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueryAddrResponse>,
            tonic::Status,
        >;
        /// tapcli: `addrs new`
        /// NewAddr makes a new address from the set of request params.
        async fn new_addr(
            &self,
            request: tonic::Request<super::NewAddrRequest>,
        ) -> std::result::Result<tonic::Response<super::Addr>, tonic::Status>;
        /// tapcli: `addrs decode`
        /// DecodeAddr decode a Taproot Asset address into a partial asset message that
        /// represents the asset it wants to receive.
        async fn decode_addr(
            &self,
            request: tonic::Request<super::DecodeAddrRequest>,
        ) -> std::result::Result<tonic::Response<super::Addr>, tonic::Status>;
        /// tapcli: `addrs receives`
        /// List all receives for incoming asset transfers for addresses that were
        /// created previously.
        async fn addr_receives(
            &self,
            request: tonic::Request<super::AddrReceivesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddrReceivesResponse>,
            tonic::Status,
        >;
        /// tapcli: `proofs verify`
        /// VerifyProof attempts to verify a given proof file that claims to be anchored
        /// at the specified genesis point.
        async fn verify_proof(
            &self,
            request: tonic::Request<super::ProofFile>,
        ) -> std::result::Result<
            tonic::Response<super::VerifyProofResponse>,
            tonic::Status,
        >;
        /// tapcli: `proofs decode`
        /// DecodeProof attempts to decode a given proof file into human readable
        /// format.
        async fn decode_proof(
            &self,
            request: tonic::Request<super::DecodeProofRequest>,
        ) -> std::result::Result<
            tonic::Response<super::DecodeProofResponse>,
            tonic::Status,
        >;
        /// tapcli: `proofs export`
        /// ExportProof exports the latest raw proof file anchored at the specified
        /// script_key.
        async fn export_proof(
            &self,
            request: tonic::Request<super::ExportProofRequest>,
        ) -> std::result::Result<tonic::Response<super::ProofFile>, tonic::Status>;
        /// tapcli: `proofs unpack`
        /// UnpackProofFile unpacks a proof file into a list of the individual raw
        /// proofs in the proof chain.
        async fn unpack_proof_file(
            &self,
            request: tonic::Request<super::UnpackProofFileRequest>,
        ) -> std::result::Result<
            tonic::Response<super::UnpackProofFileResponse>,
            tonic::Status,
        >;
        /// tapcli: `assets send`
        /// SendAsset uses one or multiple passed Taproot Asset address(es) to attempt
        /// to complete an asset send. The method returns information w.r.t the on chain
        /// send, as well as the proof file information the receiver needs to fully
        /// receive the asset.
        async fn send_asset(
            &self,
            request: tonic::Request<super::SendAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::SendAssetResponse>,
            tonic::Status,
        >;
        /// tapcli: `assets burn`
        /// BurnAsset burns the given number of units of a given asset by sending them
        /// to a provably un-spendable script key. Burning means irrevocably destroying
        /// a certain number of assets, reducing the total supply of the asset. Because
        /// burning is such a destructive and non-reversible operation, some specific
        /// values need to be set in the request to avoid accidental burns.
        async fn burn_asset(
            &self,
            request: tonic::Request<super::BurnAssetRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BurnAssetResponse>,
            tonic::Status,
        >;
        /// tapcli: `assets listburns`
        /// ListBurns lists the asset burns that this wallet has performed. These assets
        /// are not recoverable in any way. Filters may be applied to return more
        /// specific results.
        async fn list_burns(
            &self,
            request: tonic::Request<super::ListBurnsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ListBurnsResponse>,
            tonic::Status,
        >;
        /// tapcli: `getinfo`
        /// GetInfo returns the information for the node.
        async fn get_info(
            &self,
            request: tonic::Request<super::GetInfoRequest>,
        ) -> std::result::Result<tonic::Response<super::GetInfoResponse>, tonic::Status>;
        /// tapcli: `assets meta`
        /// FetchAssetMeta allows a caller to fetch the reveal meta data for an asset
        /// either by the asset ID for that asset, or a meta hash.
        async fn fetch_asset_meta(
            &self,
            request: tonic::Request<super::FetchAssetMetaRequest>,
        ) -> std::result::Result<tonic::Response<super::AssetMeta>, tonic::Status>;
        /// Server streaming response type for the SubscribeReceiveEvents method.
        type SubscribeReceiveEventsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::ReceiveEvent, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// tapcli: `events receive`
        /// SubscribeReceiveEvents allows a caller to subscribe to receive events for
        /// incoming asset transfers.
        async fn subscribe_receive_events(
            &self,
            request: tonic::Request<super::SubscribeReceiveEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeReceiveEventsStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the SubscribeSendEvents method.
        type SubscribeSendEventsStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<super::SendEvent, tonic::Status>,
            >
            + std::marker::Send
            + 'static;
        /// tapcli: `events send`
        /// SubscribeSendEvents allows a caller to subscribe to send events for outgoing
        /// asset transfers.
        async fn subscribe_send_events(
            &self,
            request: tonic::Request<super::SubscribeSendEventsRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::SubscribeSendEventsStream>,
            tonic::Status,
        >;
        ///
        /// RegisterTransfer informs the daemon about a new inbound transfer that has
        /// happened. This is used for interactive transfers where no TAP address is
        /// involved and the recipient is aware of the transfer through an out-of-band
        /// protocol but the daemon hasn't been informed about the completion of the
        /// transfer. For this to work, the proof must already be in the recipient's
        /// local universe (e.g. through the use of the universerpc.InsertProof RPC or
        /// the universe proof courier and universe sync mechanisms) and this call
        /// simply instructs the daemon to detect the transfer as an asset it owns.
        async fn register_transfer(
            &self,
            request: tonic::Request<super::RegisterTransferRequest>,
        ) -> std::result::Result<
            tonic::Response<super::RegisterTransferResponse>,
            tonic::Status,
        >;
    }
    #[derive(Debug)]
    pub struct TaprootAssetsServer<T> {
        inner: Arc<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    impl<T> TaprootAssetsServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for TaprootAssetsServer<T>
    where
        T: TaprootAssets,
        B: Body + std::marker::Send + 'static,
        B::Error: Into<StdError> + std::marker::Send + 'static,
    {
        type Response = http::Response<tonic::body::Body>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            match req.uri().path() {
                "/taprpc.TaprootAssets/ListAssets" => {
                    #[allow(non_camel_case_types)]
                    struct ListAssetsSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::ListAssetRequest>
                    for ListAssetsSvc<T> {
                        type Response = super::ListAssetResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListAssetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::list_assets(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListAssetsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/ListUtxos" => {
                    #[allow(non_camel_case_types)]
                    struct ListUtxosSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::ListUtxosRequest>
                    for ListUtxosSvc<T> {
                        type Response = super::ListUtxosResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListUtxosRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::list_utxos(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListUtxosSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/ListGroups" => {
                    #[allow(non_camel_case_types)]
                    struct ListGroupsSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::ListGroupsRequest>
                    for ListGroupsSvc<T> {
                        type Response = super::ListGroupsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListGroupsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::list_groups(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListGroupsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/ListBalances" => {
                    #[allow(non_camel_case_types)]
                    struct ListBalancesSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::ListBalancesRequest>
                    for ListBalancesSvc<T> {
                        type Response = super::ListBalancesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListBalancesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::list_balances(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListBalancesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/ListTransfers" => {
                    #[allow(non_camel_case_types)]
                    struct ListTransfersSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::ListTransfersRequest>
                    for ListTransfersSvc<T> {
                        type Response = super::ListTransfersResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListTransfersRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::list_transfers(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListTransfersSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/StopDaemon" => {
                    #[allow(non_camel_case_types)]
                    struct StopDaemonSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::StopRequest>
                    for StopDaemonSvc<T> {
                        type Response = super::StopResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::StopRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::stop_daemon(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = StopDaemonSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/DebugLevel" => {
                    #[allow(non_camel_case_types)]
                    struct DebugLevelSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::DebugLevelRequest>
                    for DebugLevelSvc<T> {
                        type Response = super::DebugLevelResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DebugLevelRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::debug_level(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DebugLevelSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/QueryAddrs" => {
                    #[allow(non_camel_case_types)]
                    struct QueryAddrsSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::QueryAddrRequest>
                    for QueryAddrsSvc<T> {
                        type Response = super::QueryAddrResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueryAddrRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::query_addrs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = QueryAddrsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/NewAddr" => {
                    #[allow(non_camel_case_types)]
                    struct NewAddrSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::NewAddrRequest>
                    for NewAddrSvc<T> {
                        type Response = super::Addr;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::NewAddrRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::new_addr(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = NewAddrSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/DecodeAddr" => {
                    #[allow(non_camel_case_types)]
                    struct DecodeAddrSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::DecodeAddrRequest>
                    for DecodeAddrSvc<T> {
                        type Response = super::Addr;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DecodeAddrRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::decode_addr(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DecodeAddrSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/AddrReceives" => {
                    #[allow(non_camel_case_types)]
                    struct AddrReceivesSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::AddrReceivesRequest>
                    for AddrReceivesSvc<T> {
                        type Response = super::AddrReceivesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddrReceivesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::addr_receives(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = AddrReceivesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/VerifyProof" => {
                    #[allow(non_camel_case_types)]
                    struct VerifyProofSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<T: TaprootAssets> tonic::server::UnaryService<super::ProofFile>
                    for VerifyProofSvc<T> {
                        type Response = super::VerifyProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ProofFile>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::verify_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = VerifyProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/DecodeProof" => {
                    #[allow(non_camel_case_types)]
                    struct DecodeProofSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::DecodeProofRequest>
                    for DecodeProofSvc<T> {
                        type Response = super::DecodeProofResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::DecodeProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::decode_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = DecodeProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/ExportProof" => {
                    #[allow(non_camel_case_types)]
                    struct ExportProofSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::ExportProofRequest>
                    for ExportProofSvc<T> {
                        type Response = super::ProofFile;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ExportProofRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::export_proof(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ExportProofSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/UnpackProofFile" => {
                    #[allow(non_camel_case_types)]
                    struct UnpackProofFileSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::UnpackProofFileRequest>
                    for UnpackProofFileSvc<T> {
                        type Response = super::UnpackProofFileResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::UnpackProofFileRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::unpack_proof_file(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = UnpackProofFileSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/SendAsset" => {
                    #[allow(non_camel_case_types)]
                    struct SendAssetSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::SendAssetRequest>
                    for SendAssetSvc<T> {
                        type Response = super::SendAssetResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SendAssetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::send_asset(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SendAssetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/BurnAsset" => {
                    #[allow(non_camel_case_types)]
                    struct BurnAssetSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::BurnAssetRequest>
                    for BurnAssetSvc<T> {
                        type Response = super::BurnAssetResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BurnAssetRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::burn_asset(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = BurnAssetSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/ListBurns" => {
                    #[allow(non_camel_case_types)]
                    struct ListBurnsSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::ListBurnsRequest>
                    for ListBurnsSvc<T> {
                        type Response = super::ListBurnsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ListBurnsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::list_burns(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = ListBurnsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/GetInfo" => {
                    #[allow(non_camel_case_types)]
                    struct GetInfoSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::GetInfoRequest>
                    for GetInfoSvc<T> {
                        type Response = super::GetInfoResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetInfoRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::get_info(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = GetInfoSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/FetchAssetMeta" => {
                    #[allow(non_camel_case_types)]
                    struct FetchAssetMetaSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::FetchAssetMetaRequest>
                    for FetchAssetMetaSvc<T> {
                        type Response = super::AssetMeta;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::FetchAssetMetaRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::fetch_asset_meta(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = FetchAssetMetaSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/SubscribeReceiveEvents" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeReceiveEventsSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::ServerStreamingService<
                        super::SubscribeReceiveEventsRequest,
                    > for SubscribeReceiveEventsSvc<T> {
                        type Response = super::ReceiveEvent;
                        type ResponseStream = T::SubscribeReceiveEventsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubscribeReceiveEventsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::subscribe_receive_events(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeReceiveEventsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/SubscribeSendEvents" => {
                    #[allow(non_camel_case_types)]
                    struct SubscribeSendEventsSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::ServerStreamingService<
                        super::SubscribeSendEventsRequest,
                    > for SubscribeSendEventsSvc<T> {
                        type Response = super::SendEvent;
                        type ResponseStream = T::SubscribeSendEventsStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::SubscribeSendEventsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::subscribe_send_events(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = SubscribeSendEventsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/taprpc.TaprootAssets/RegisterTransfer" => {
                    #[allow(non_camel_case_types)]
                    struct RegisterTransferSvc<T: TaprootAssets>(pub Arc<T>);
                    impl<
                        T: TaprootAssets,
                    > tonic::server::UnaryService<super::RegisterTransferRequest>
                    for RegisterTransferSvc<T> {
                        type Response = super::RegisterTransferResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::RegisterTransferRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as TaprootAssets>::register_transfer(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let method = RegisterTransferSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        let mut response = http::Response::new(
                            tonic::body::Body::default(),
                        );
                        let headers = response.headers_mut();
                        headers
                            .insert(
                                tonic::Status::GRPC_STATUS,
                                (tonic::Code::Unimplemented as i32).into(),
                            );
                        headers
                            .insert(
                                http::header::CONTENT_TYPE,
                                tonic::metadata::GRPC_CONTENT_TYPE,
                            );
                        Ok(response)
                    })
                }
            }
        }
    }
    impl<T> Clone for TaprootAssetsServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    /// Generated gRPC service name
    pub const SERVICE_NAME: &str = "taprpc.TaprootAssets";
    impl<T> tonic::server::NamedService for TaprootAssetsServer<T> {
        const NAME: &'static str = SERVICE_NAME;
    }
}
